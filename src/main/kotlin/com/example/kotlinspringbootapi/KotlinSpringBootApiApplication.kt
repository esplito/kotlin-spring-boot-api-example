package com.example.kotlinspringbootapi

import com.example.kotlinspringbootapi.model.Message
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.boot.web.client.RestTemplateBuilder
import org.springframework.context.annotation.Bean
import org.springframework.data.crossstore.ChangeSetPersister
import org.springframework.data.repository.CrudRepository
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.stereotype.Service
import org.springframework.web.bind.annotation.*
import org.springframework.web.client.RestClientException
import org.springframework.web.client.RestTemplate
import java.util.*

@SpringBootApplication
class KotlinSpringBootApiApplication {
    @Bean
    fun restTemplate(builder: RestTemplateBuilder): RestTemplate = builder.build()
}

fun main(args: Array<String>) {
    runApplication<KotlinSpringBootApiApplication>(*args)
}

interface MessageRepository : CrudRepository<Message, String>


/*
 `val db: JdbcTemplate` is the constructor's argument.
According to the Kotlin convention, if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses.
Such syntax is also known as trailing lambda.

_ is used to replace the name of a parameter that is unused.
 */
@Service
class MessageService(val db: MessageRepository) {
    fun findMessages(): List<Message> = db.findAll().toList();

    /*
     üö® The .query() function that is used to fetch the message by its id is a Kotlin extension function provided by the Spring Framework. It requires an additional import `import org.springframework.jdbc.core.query`.

      fun findMessageById(id: String): List<Message> = db.query("select * from messages where id = ?", id, ) { response, _ ->
        Message(response.getString("id"), response.getString("text"))
    }

     */
    fun findMessageById(id: String): List<Message> = db.findById(id).toList()

    fun save(message: Message) {
        /*
        ‚ÑπÔ∏è Comment regarding implementation before switching to CrudRepository ‚ÑπÔ∏è
        we are using the "Elvis operator" ?: here.
        (if-not-null-else shorthand): https://kotlinlang.org/docs/null-safety.html#elvis-operator
        If the expression to the left of ?: is not null, the Elvis operator returns it; otherwise, it returns the expression to the right.
        Note that the expression on the right-hand side is evaluated only if the left-hand side is null.

        val id = message.id ?: UUID.randomUUID().toString()
        db.update(
                "insert into messages values (?, ?)",
                id, message.text
        )

        */

        /*
        If the id isn‚Äôt null, CrudRepository assumes that the object already exists in the database and this is an update operation as opposed to an insert operation. After the insert operation, the id will be generated by the data store and assigned back to the Message instance. This is why the id property should be declared using the var keyword.
        */
        db.save(message) // works as both CREATE & UPDATE as comment above states
    }

    fun delete(id: String) {
        db.deleteById(id)
    }

    /*
    Note from the tutorial ‚ÑπÔ∏è:
    The return type of the findById() function in the CrudRepository interface is an instance of the Optional class. However, it would be convenient to return a List with a single message for consistency. For that, you need to unwrap the Optional value if it‚Äôs present, and return a list with the value. This can be implemented as an extension function to the Optional type.
    In the code, Optional<out T>.toList(), .toList() is the extension function for Optional. Extension functions allow you to write additional functions to any classes, which is especially useful when you want to extend functionality of some library class.
    */
    fun <T : Any> Optional<out T>.toList(): List<T> =
            if (isPresent) listOf(get()) else emptyList()
}

@RestController
class MessageController (val service: MessageService) {
    /*
    fun index(@RequestParam("name") name: String) = "Hello, $name!"

    index() is an example of a "single-expression" function (since it contains only one statement), which means that curly braces can be omitted and body specified after `=`
    Return type is infered to String.

    ‚ÑπÔ∏è Any controller in the Spring application renders JSON response by default if Jackson library is on the classpath.
    The application responds with a JSON document if the endpoint returns a data structure that can be serialized to JSON.

    listOf creates a read-only list. (you can use mutableListOf() if you want a mutable one)
    */

    @ExceptionHandler(NoSuchElementException::class)
    fun handleNotFound(e: NoSuchElementException): ResponseEntity<String> = ResponseEntity(e.message, HttpStatus.NOT_FOUND)

    @GetMapping("/")
    fun index(): List<Message> = service.findMessages()

    @GetMapping("/{id}")
    fun index(@PathVariable id: String): List<Message> = service.findMessageById(id)

    @PostMapping("/")
    fun post(@RequestBody message: Message) {
        // Works as both CREATE & UPDATE
        service.save(message)
    }

    @DeleteMapping("/{id}")
    fun delete(@PathVariable id: String) {
        service.delete(id)
    }

}
